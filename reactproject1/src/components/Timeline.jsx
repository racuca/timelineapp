import React, { useRef, useEffect } from "react";
import * as d3 from "d3";

const Timeline = ({ svgRef, containerRef, zoomBehaviorRef, events, isVertical }) => {
    const handleZoomIn = () => {
        const svg = d3.select(svgRef.current);
        svg.transition().call(zoomBehaviorRef.current.scaleBy, 1.2); // 1.2배 줌 인
    };

    const handleZoomOut = () => {
        const svg = d3.select(svgRef.current);
        svg.transition().call(zoomBehaviorRef.current.scaleBy, 0.8); // 0.8배 줌 아웃
    };

    const handleZoomReset = () => {
        const svg = d3.select(svgRef.current);
        svg.transition().call(zoomBehaviorRef.current.transform, d3.zoomIdentity); // 초기 상태로 줌 리셋
    };

    const baseWidth = 800; // 기본 타임라인 너비
    const baseEventSpacing = 200; // 이벤트 간 기본 간격

    console.log("events.length ", events.length);
    console.log("events ", events);

    useEffect(() => {
        const svg = d3.select(svgRef.current);
        const size = Math.max(baseWidth, events.length * baseEventSpacing + 100); // 타임라인 너비 계산
        const height = isVertical ? size : 400; // 세로 방향이면 높이를 늘림
        const width = isVertical ? 400 : size; // 가로 방향이면 너비를 늘림

        svg.attr("width", width).attr("height", height).style("background", "#f9f9f9");

        // Clear previous elements
        svg.selectAll("*").remove();

        // Append a group for zoomable content
        const g = svg.append("g");

        // Define zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.5, 3]) // 최소 0.5배, 최대 3배 줌
            .on("zoom", (event) => {
                g.attr("transform", event.transform); // 그룹 요소에 변환 적용
            });

        svg.call(zoom); // SVG에 줌 이벤트 연결
        zoomBehaviorRef.current = zoom;

        // Draw the timeline
        const linePos = isVertical ? width / 2 : height / 2; // 세로/가로 방향에 따라 선 위치 설정
        g.append("line")
            .attr("x1", isVertical ? linePos : 50)
            .attr("y1", isVertical ? 50 : linePos)
            .attr("x2", isVertical ? linePos : width - 50)
            .attr("y2", isVertical ? height - 50 : linePos)
            .attr("stroke", "black")
            .attr("stroke-width", 2);
        
        // Draw events with branches and cards
        const eventGroups = g.selectAll(".event")
            .data(events)
            .enter()
            .append("g")
            .attr("class", "event")
            .attr(
                "transform",
                (d, i) =>
                    `translate(${isVertical ? linePos : 50 + i * baseEventSpacing}, ${isVertical ? 50 + i * baseEventSpacing : linePos
                    })`
            );

        // Add text and dynamically calculate box size
        const textElements = eventGroups.append("text")
            .attr("x", (d, i) => (isVertical ? (i % 2 === 0 ? -90 : 100) : 0))
            .attr("y", (d, i) => (isVertical ? 20 : i % 2 === 0 ? -80 : 50))
            .attr("text-anchor", "left")
            .style("font-size", "12px");

        // 두 줄로 텍스트 추가: 첫 줄은 d.createdt, 둘째 줄은 d.description
        textElements.each(function (d, i) {
            const text = d3.select(this);
            text.append("tspan")
                .text(d.createdt) // 첫 번째 줄 (날짜)
                .attr("x", (d, i) => (isVertical ? (i % 2 === 0 ? -200 : 0) : 0))
                .attr("dy", "0em")
                .style("font-weight", "bold"); // 날짜 강조

            text.append("tspan")
                .text(d.description) // 두 번째 줄 (설명)
                .attr("x", (d, i) => (isVertical ? (i % 2 === 0 ? -200 : 0) : 0))
                .attr("dy", "1.5em");
        });

        // 박스 추가
        textElements.each(function (d, i) {
            const bbox = this.getBBox(); // Get text size dynamically
            const padding = 20;

            // Add background rectangle for each text
            d3.select(this.parentNode)
                .insert("rect", "text")
                .attr("x", (d, i) => (isVertical ? (i % 2 === 0 ? bbox.x : 100) : bbox.x - 10))
                .attr("y", (d, i) => (isVertical ? (i % 2 === 0 ? bbox.y : 100) : bbox.y - 10))
                .attr("width", bbox.width + padding)
                .attr("height", bbox.height + padding)
                .attr("rx", 4)  // 모서리 radius
                .attr("ry", 4)
                .attr("fill", "white")
                .attr("stroke", "steelblue")
                .attr("stroke-width", 1.5)
                .lower(); // Send rectangle to the back

            // 타임라인과 박스를 연결하는 선 추가
            d3.select(this.parentNode)
                .append("line")
                .attr("x1", isVertical ? linePos : bbox.x)
                .attr("y1", isVertical ? 0 : 0)
                .attr("x2", isVertical ? (i % 2 === 0 ? linePos - 100 : linePos + 100) : bbox.x)
                .attr("y2", isVertical ? bbox.y : (i % 2 === 0 ? bbox.y + bbox.height + padding - 10: bbox.y - padding + 10))
                .attr("stroke", "gray")
                .attr("stroke-width", 1.5);
        });

    }, [events, isVertical]);

    return (
        <div>
            <div className="button-container">
                <button onClick={handleZoomIn}>Zoom In</button>
                <button onClick={handleZoomOut}>Zoom Out</button>
                <button onClick={handleZoomReset}>Reset Zoom</button>
            </div>
            <div
                ref={containerRef}
                style={{ width: "800px", overflowX: "scroll", border: "1px solid #ddd" }}
            >
                <svg ref={svgRef}></svg>
            </div>
        </div>
    );
};

export default Timeline;